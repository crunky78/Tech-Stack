JVM 구조
Garbage collection
문자열 클래스

##JVM 구조

> 자바 가상 머신의 동작방식
1. 자바로 개발된 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당합니다.
2. 자바 컴파일러가 자바 소스코드를 자바 바이트코드로 컴파일합니다.
3. Class Loader를 통해 JVM Runtime Data Area로 로딩합니다.
4. Runtime Data Area에 로딩된 .class들은 Execution Engine을 통해 해석합니다.
5. 해석된 바이트 코드는 Runtime Data Area의 각 영역에 배치되어 수행하며 이 과정에서 Execution Engine에 의해 GC의 작동과 스레드 동기화가 이루어집니다.

> JVM의 구조

자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행중인 런타임에서야 모든 코드가 자바 가상머신과 연결됩니다.
이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 클래스 로더 입니다.
자바에서 소스를 작성하면 .java 파일이 생성되고 .java 소스를 컴파일러가 컴파일하면 .class 파일이 생성되는데 클래스 로더는 .class 파일을 묶어서 JVM이 운영체제로부터
할당받은 메모리 영역인 Runtime Data Area로 적재합니다.

##Garbage collection

>Garbage Collection이란?

가비지 컬렉션은 GC라고도 부르며, 자바의 메모리 관리 방법 중 하나이다. JVM의 Heap 영역에서 동적으로 할당했던 메모리 영역중 필요없게 된 메모리 영역을 주기적으로 삭제하는 프로세스.
C나 C++에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 하는 반면 Java는 JVM에 탑재되어 있는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 개발자 입장에서 메모리 관리, 메모리 누수 문제에 대해 완벽하게 관리하지 않아도 되어 오롯이 개발에만 집중할 수 있다는 장점이 있다.

> GC의 단점
1. 개발자가 메모리가 언제 해제되는지 정확하게 알 수 없다.
2. 가비지컬렉션이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생한다.

> GC의 대상이 되는 객체들

실질적으로 Heap영역에서 생성되고 Method Area나 Stack Area등 Root Area에서는 Heap Area에 생성된 객체의 주소만 참조하는 형식으로 구성됩니다. 하지만 이렇게 생성된 Heap Area의 객체들이 메서드가 끝나는 등 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상이 발생하면 주기적으로 가비지 컬렉터가 제거해줍니다.


## 문자열 클래스
> charAt(int index) : char

특정 위치의 문자를 리턴

